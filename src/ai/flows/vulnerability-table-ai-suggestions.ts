// src/ai/flows/vulnerability-table-ai-suggestions.ts
'use server';

/**
 * @fileOverview This file defines a Genkit flow for analyzing vulnerable packages and providing AI-powered suggestions.
 *
 * - analyzeVulnerabilities - Analyzes a list of packages and their versions against a vulnerability database and provides suggestions.
 * - VulnerabilityAnalysisInput - The input type for the analyzeVulnerabilities function, a list of package names and versions.
 * - VulnerabilityAnalysisOutput - The return type for the analyzeVulnerabilities function, a list of analysis results with AI suggestions.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

// Define the input schema for a single package and its version
const PackageInfoSchema = z.object({
  packageName: z.string().describe('The name of the package.'),
  installedVersion: z.string().describe('The installed version of the package.'),
});

// Define the input schema as an array of PackageInfo objects
const VulnerabilityAnalysisInputSchema = z.array(PackageInfoSchema).describe('An array of package names and their installed versions.');
export type VulnerabilityAnalysisInput = z.infer<typeof VulnerabilityAnalysisInputSchema>;

// Define the output schema for a single analysis result
const AnalysisResultSchema = z.object({
  packageName: z.string().describe('The name of the package.'),
  installedVersion: z.string().describe('The installed version of the package.'),
  isVulnerable: z.boolean().describe('Whether the package is vulnerable.'),
  vulnerableVersion: z.string().optional().describe('The vulnerable version of the package, if any.'),
  suggestion: z.string().describe('AI-powered suggestion for remediation or transition.'),
});

// Define the output schema as an array of analysis results
const VulnerabilityAnalysisOutputSchema = z.array(AnalysisResultSchema);
export type VulnerabilityAnalysisOutput = z.infer<typeof VulnerabilityAnalysisOutputSchema>;

// Exported function to analyze vulnerabilities
export async function analyzeVulnerabilities(input: VulnerabilityAnalysisInput): Promise<VulnerabilityAnalysisOutput> {
  return vulnerabilityAnalysisFlow(input);
}

const vulnerabilityAnalysisPrompt = ai.definePrompt({
  name: 'vulnerabilityAnalysisPrompt',
  input: {
    schema: z.object({
      packageName: z.string(),
      installedVersion: z.string(),
      vulnerableVersion: z.string().optional(),
      isVulnerable: z.boolean(),
    }),
  },
  output: {
    schema: z.object({
      suggestion: z.string(),
    }),
  },
  prompt: `You are a security expert providing advice on software packages.
Package: {{{packageName}}}
Installed Version: {{{installedVersion}}}
{{#if isVulnerable}}
Vulnerable Version: {{{vulnerableVersion}}}
This package is vulnerable. Provide a concise suggestion for how to remediate this vulnerability.
{{else}}
This package is not known to be vulnerable in the provided database. Provide a message indicating that the package is safe according to the scan.
{{/if}}
`,
});

const vulnerabilityAnalysisFlow = ai.defineFlow(
  {
    name: 'vulnerabilityAnalysisFlow',
    inputSchema: VulnerabilityAnalysisInputSchema,
    outputSchema: VulnerabilityAnalysisOutputSchema,
  },
  async input => {
    const vulnerabilityDatabase = [
      {
        packageName: 'backslash',
        vulnerableVersion: '0.2.1',
      },
      {
        packageName: 'chalk-template',
        vulnerableVersion: '1.1.1',
      },
      {
        packageName: 'supports-hyperlinks',
        vulnerableVersion: '4.1.1',
      },
      {
        packageName: 'has-ansi',
        vulnerableVersion: '6.0.1',
      },
      {
        packageName: 'simple-swizzle',
        vulnerableVersion: '0.2.3',
      },
      {
        packageName: 'color-string',
        vulnerableVersion: '2.1.1',
      },
      {
        packageName: 'error-ex',
        vulnerableVersion: '1.3.3',
      },
      {
        packageName: 'color-name',
        vulnerableVersion: '2.0.1',
      },
      {
        packageName: 'is-arrayish',
        vulnerableVersion: '0.3.3',
      },
      {
        packageName: 'slice-ansi',
        vulnerableVersion: '7.1.1',
      },
      {
        packageName: 'color-convert',
        vulnerableVersion: '3.1.1',
      },
      {
        packageName: 'wrap-ansi',
        vulnerableVersion: '9.0.1',
      },
      {
        packageName: 'ansi-regex',
        vulnerableVersion: '6.2.1',
      },
      {
        packageName: 'supports-color',
        vulnerableVersion: '10.2.1',
      },
      {
        packageName: 'strip-ansi',
        vulnerableVersion: '7.1.1',
      },
      {
        packageName: 'chalk',
        vulnerableVersion: '5.6.1',
      },
      {
        packageName: 'debug',
        vulnerableVersion: '4.4.2',
      },
      {
        packageName: 'ansi-styles',
        vulnerableVersion: '6.2.2',
      },
    ];

    const analysisResults: VulnerabilityAnalysisOutput = [];

    for (const packageInfo of input) {
      const vulnerability = vulnerabilityDatabase.find(
        v => packageInfo.packageName === v.packageName
      );

      const isVulnerable = !!vulnerability;

      const promptInput = {
        packageName: packageInfo.packageName,
        installedVersion: packageInfo.installedVersion,
        vulnerableVersion: vulnerability?.vulnerableVersion,
        isVulnerable: isVulnerable,
      };

      const {output} = await vulnerabilityAnalysisPrompt(promptInput);

      analysisResults.push({
        packageName: packageInfo.packageName,
        installedVersion: packageInfo.installedVersion,
        isVulnerable: isVulnerable,
        vulnerableVersion: vulnerability?.vulnerableVersion,
        suggestion: output!.suggestion,
      });
    }

    return analysisResults;
  }
);
